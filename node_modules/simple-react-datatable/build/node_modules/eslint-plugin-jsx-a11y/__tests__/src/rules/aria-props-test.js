'use strict';

var _ariaQuery = require('aria-query');

var _eslint = require('eslint');

var _parserOptionsMapper = require('../../__util__/parserOptionsMapper');

var _parserOptionsMapper2 = _interopRequireDefault(_parserOptionsMapper);

var _ariaProps = require('../../../src/rules/aria-props');

var _ariaProps2 = _interopRequireDefault(_ariaProps);

var _getSuggestion = require('../../../src/util/getSuggestion');

var _getSuggestion2 = _interopRequireDefault(_getSuggestion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint-env jest */
/**
 * @fileoverview Enforce all aria-* properties are valid.
 * @author Ethan Cohen
 */

// -----------------------------------------------------------------------------
// Requirements
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

var ruleTester = new _eslint.RuleTester();
var ariaAttributes = [].concat(_toConsumableArray(_ariaQuery.aria.keys()));

var errorMessage = function errorMessage(name) {
  var suggestions = (0, _getSuggestion2.default)(name, ariaAttributes);
  var message = name + ': This attribute is an invalid ARIA attribute.';

  if (suggestions.length > 0) {
    return {
      type: 'JSXAttribute',
      message: message + ' Did you mean to use ' + suggestions + '?'
    };
  }

  return {
    type: 'JSXAttribute',
    message: message
  };
};

// Create basic test cases using all valid role types.
var basicValidityTests = ariaAttributes.map(function (prop) {
  return {
    code: '<div ' + prop.toLowerCase() + '="foobar" />'
  };
});

ruleTester.run('aria-props', _ariaProps2.default, {
  valid: [
  // Variables should pass, as we are only testing literals.
  { code: '<div />' }, { code: '<div></div>' }, { code: '<div aria="wee"></div>' }, // Needs aria-*
  { code: '<div abcARIAdef="true"></div>' }, { code: '<div fooaria-foobar="true"></div>' }, { code: '<div fooaria-hidden="true"></div>' }, { code: '<Bar baz />' }].concat(basicValidityTests).map(_parserOptionsMapper2.default),
  invalid: [{ code: '<div aria-="foobar" />', errors: [errorMessage('aria-')] }, {
    code: '<div aria-labeledby="foobar" />',
    errors: [errorMessage('aria-labeledby')]
  }, {
    code: '<div aria-skldjfaria-klajsd="foobar" />',
    errors: [errorMessage('aria-skldjfaria-klajsd')]
  }].map(_parserOptionsMapper2.default)
});