'use strict';

var _ariaQuery = require('aria-query');

var _eslint = require('eslint');

var _parserOptionsMapper = require('../../__util__/parserOptionsMapper');

var _parserOptionsMapper2 = _interopRequireDefault(_parserOptionsMapper);

var _ariaRole = require('../../../src/rules/aria-role');

var _ariaRole2 = _interopRequireDefault(_ariaRole);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint-env jest */
/**
 * @fileoverview Enforce aria role attribute is valid.
 * @author Ethan Cohen
 */

// -----------------------------------------------------------------------------
// Requirements
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

var ruleTester = new _eslint.RuleTester();

var errorMessage = {
  message: 'Elements with ARIA roles must use a valid, non-abstract ARIA role.',
  type: 'JSXAttribute'
};

var validRoles = [].concat(_toConsumableArray(_ariaQuery.roles.keys())).filter(function (role) {
  return _ariaQuery.roles.get(role).abstract === false;
});
var invalidRoles = [].concat(_toConsumableArray(_ariaQuery.roles.keys())).filter(function (role) {
  return _ariaQuery.roles.get(role).abstract === true;
});

var createTests = function createTests(roleNames) {
  return roleNames.map(function (role) {
    return {
      code: '<div role="' + role.toLowerCase() + '" />'
    };
  });
};

var validTests = createTests(validRoles);
var invalidTests = createTests(invalidRoles).map(function (test) {
  var invalidTest = Object.assign({}, test);
  invalidTest.errors = [errorMessage];
  return invalidTest;
});

var ignoreNonDOMSchema = [{
  ignoreNonDOM: true
}];

ruleTester.run('aria-role', _ariaRole2.default, {
  valid: [
  // Variables should pass, as we are only testing literals.
  { code: '<div />' }, { code: '<div></div>' }, { code: '<div role={role} />' }, { code: '<div role={role || "button"} />' }, { code: '<div role={role || "foobar"} />' }, { code: '<div role="tabpanel row" />' }, { code: '<div role="switch" />' }, { code: '<div role="doc-abstract" />' }, { code: '<div role="doc-appendix doc-bibliography" />' }, { code: '<Bar baz />' }, { code: '<Foo role="bar" />', options: ignoreNonDOMSchema }].concat(validTests).map(_parserOptionsMapper2.default),

  invalid: [{ code: '<div role="foobar" />', errors: [errorMessage] }, { code: '<div role="datepicker"></div>', errors: [errorMessage] }, { code: '<div role="range"></div>', errors: [errorMessage] }, { code: '<div role=""></div>', errors: [errorMessage] }, { code: '<div role="tabpanel row foobar"></div>', errors: [errorMessage] }, { code: '<div role="tabpanel row range"></div>', errors: [errorMessage] }, { code: '<div role="doc-endnotes range"></div>', errors: [errorMessage] }, { code: '<div role />', errors: [errorMessage] }, { code: '<div role={null}></div>', errors: [errorMessage] }, { code: '<Foo role="datepicker" />', errors: [errorMessage] }].concat(invalidTests).map(_parserOptionsMapper2.default)
});