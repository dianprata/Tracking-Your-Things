'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* eslint-env mocha */
/* eslint no-template-curly-in-string: 0 */


var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _helper = require('../helper');

var _getPropValue = require('../../src/getPropValue');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('getLiteralPropValue', function () {
  it('should export a function', function () {
    var expected = 'function';
    var actual = typeof _getPropValue.getLiteralPropValue === 'undefined' ? 'undefined' : _typeof(_getPropValue.getLiteralPropValue);

    _assert2.default.equal(expected, actual);
  });

  it('should return undefined when not provided with a JSXAttribute', function () {
    var expected = undefined;
    var actual = (0, _getPropValue.getLiteralPropValue)(1);

    _assert2.default.equal(expected, actual);
  });

  it('should throw error when trying to get value from unknown node type', function () {
    var prop = {
      type: 'JSXAttribute',
      value: {
        type: 'JSXExpressionContainer'
      }
    };

    _assert2.default.throws(function () {
      (0, _getPropValue.getLiteralPropValue)(prop);
    }, Error);
  });

  describe('Null', function () {
    it('should return true when no value is given', function () {
      var prop = (0, _helper.extractProp)('<div foo />');

      var expected = true;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Literal', function () {
    it('should return correct string if value is a string', function () {
      var prop = (0, _helper.extractProp)('<div foo="bar" />');

      var expected = 'bar';
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should return correct string if value is a string expression', function () {
      var prop = (0, _helper.extractProp)('<div foo={"bar"} />');

      var expected = 'bar';
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should return correct integer if value is a integer expression', function () {
      var prop = (0, _helper.extractProp)('<div foo={1} />');

      var expected = 1;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should convert "true" to boolean type', function () {
      var prop = (0, _helper.extractProp)('<div foo="true" />');

      var expected = true;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should convert "TrUE" to boolean type', function () {
      var prop = (0, _helper.extractProp)('<div foo="TrUE" />');

      var expected = true;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should convert "false" to boolean type', function () {
      var prop = (0, _helper.extractProp)('<div foo="false" />');

      var expected = false;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should convert "FaLsE" to boolean type', function () {
      var prop = (0, _helper.extractProp)('<div foo="FaLsE" />');

      var expected = false;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should return String null when value is null', function () {
      var prop = (0, _helper.extractProp)('<div foo={null} />');

      var expected = 'null';
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('JSXElement', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo=<bar /> />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Identifier', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should return undefined when identifier is literally `undefined`', function () {
      var prop = (0, _helper.extractProp)('<div foo={undefined} />');

      var expected = undefined;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Template literal', function () {
    it('should return template literal with vars wrapped in curly braces', function () {
      var prop = (0, _helper.extractProp)('<div foo={`bar ${baz}`} />');

      var expected = 'bar {baz}';
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should drop variables in template literals that are literally undefined', function () {
      var prop = (0, _helper.extractProp)('<div foo={`bar ${undefined}`} />');

      var expected = 'bar ';
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Tagged Template literal', function () {
    it('should return template literal with vars wrapped in curly braces', function () {
      var prop = (0, _helper.extractProp)('<div foo={noop`bar ${baz}`} />');

      var expected = 'bar {baz}';
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should drop variables in template literals that are literally undefined', function () {
      var prop = (0, _helper.extractProp)('<div foo={noop`bar ${undefined}`} />');

      var expected = 'bar ';
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Arrow function expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={ () => { return "bar"; }} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Function expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={ function() { return "bar"; } } />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Logical expression', function () {
    it('should return null for && operator', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar && baz} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should return null for || operator', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar || baz} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Member expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar.baz} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Call expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar()} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Unary expression', function () {
    it('should correctly evaluate an expression that prefixes with -', function () {
      var prop = (0, _helper.extractProp)('<div foo={-bar} />');

      // -"bar" => NaN
      var expected = true;
      var actual = isNaN((0, _getPropValue.getLiteralPropValue)(prop));

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that prefixes with -', function () {
      var prop = (0, _helper.extractProp)('<div foo={-42} />');

      var expected = -42;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that prefixes with +', function () {
      var prop = (0, _helper.extractProp)('<div foo={+bar} />');

      // +"bar" => NaN
      var expected = true;
      var actual = isNaN((0, _getPropValue.getLiteralPropValue)(prop));

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that prefixes with +', function () {
      var prop = (0, _helper.extractProp)('<div foo={+42} />');

      var expected = 42;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that prefixes with !', function () {
      var prop = (0, _helper.extractProp)('<div foo={!bar} />');

      var expected = false; // !"bar" === false
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that prefixes with ~', function () {
      var prop = (0, _helper.extractProp)('<div foo={~bar} />');

      var expected = -1; // ~"bar" === -1
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should return true when evaluating `delete foo`', function () {
      var prop = (0, _helper.extractProp)('<div foo={delete x} />');

      var expected = true;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    it('should return undefined when evaluating `void foo`', function () {
      var prop = (0, _helper.extractProp)('<div foo={void x} />');

      var expected = undefined;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });

    // TODO: We should fix this to check to see if we can evaluate it.
    it('should return undefined when evaluating `typeof foo`', function () {
      var prop = (0, _helper.extractProp)('<div foo={typeof x} />');

      var expected = undefined;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Update expression', function () {
    it('should correctly evaluate an expression that prefixes with ++', function () {
      var prop = (0, _helper.extractProp)('<div foo={++bar} />');

      // ++"bar" => NaN
      var expected = true;
      var actual = isNaN((0, _getPropValue.getLiteralPropValue)(prop));

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that prefixes with --', function () {
      var prop = (0, _helper.extractProp)('<div foo={--bar} />');

      // --"bar" => NaN
      var expected = true;
      var actual = isNaN((0, _getPropValue.getLiteralPropValue)(prop));

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that suffixes with ++', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar++} />');

      // "bar"++ => NaN
      var expected = true;
      var actual = isNaN((0, _getPropValue.getLiteralPropValue)(prop));

      _assert2.default.equal(expected, actual);
    });

    it('should correctly evaluate an expression that suffixes with --', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar--} />');

      // "bar"-- => NaN
      var expected = true;
      var actual = isNaN((0, _getPropValue.getLiteralPropValue)(prop));

      _assert2.default.equal(expected, actual);
    });
  });

  describe('This expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={this} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Conditional expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={bar ? baz : bam} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Binary expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={1 == "1"} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.equal(expected, actual);
    });
  });

  describe('Object expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={ { bar: "baz" } } />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.deepEqual(expected, actual);
    });
  });

  describe('New expression', function () {
    it('should return null', function () {
      var prop = (0, _helper.extractProp)('<div foo={new Bar()} />');

      var expected = null;
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.deepEqual(expected, actual);
    });
  });

  describe('Array expression', function () {
    it('should evaluate to correct representation of the the array in props', function () {
      var prop = (0, _helper.extractProp)('<div foo={["bar", 42, null]} />');

      var expected = ['bar', 42];
      var actual = (0, _getPropValue.getLiteralPropValue)(prop);

      _assert2.default.deepEqual(expected, actual);
    });
  });

  it('should return an empty array provided an empty array in props', function () {
    var prop = (0, _helper.extractProp)('<div foo={[]} />');

    var expected = [];
    var actual = (0, _getPropValue.getLiteralPropValue)(prop);

    _assert2.default.deepEqual(expected, actual);
  });
});